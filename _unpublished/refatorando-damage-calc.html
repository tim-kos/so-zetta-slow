<p>Mais um post 'reflexivo'. Desta vez, ao menos, é sobre o design de um dos programas que me ajudaram a aprender um pouco de JavaScript: minha calculadora de dano para Pokémon, a damageCalc. Basicamente, ela tem um monte de inputs (level, atk, def, items, abilities, etc, etc, etc) e dá como output o range a qual o dano pertence, com mais algumas informações. Podem vê-la funcionando em <a href="http://mojambo.net/calc/" target="_blank">mojambo.net/calc</a>.</p>

<h3>Pequena história</h3>

<p>Inicialmente, eu usava um programinha em C (linguagem ensinada no 1<sup>o</sup> ano da Poli) bem simples que lia dados de um input.txt e calculava um monte de estatísticas em um output.txt. Com o tempo, começaram a querer usá-la e resolvi estudar programação web - comecei a escrever a calculadora em JavaScript.</p>

<p>Na primeira versão sequer usava módulos ou namespacing. Foi quando comecei a ler <a href='http://onox.com.br/2011/11/dois-otimos-livros-sobre-javascript/'>The Good Parts</a> e fui melhorando aos poucos... até que se tornou um amontoado de código. Um spaguetti. Resolvi jogar o código fora e reescrever; é um projetinho pessoal com uma base de usuários não tão grande.</p>

<p>Me saí bem melhor. Consegui implementar quase tudo que uma calculadora precisa, inclusive alguns <i>edge cases</i> específicos do jogo. Chamei essa de versão 1.0.</p>

<h3>Começam os problemas</h3>

<p>Depois de algumas semanas do lançamento, comecei a receber sugestões (e reclamações). A maioria eram pedidos para implementar algum efeito específico. Pois bem, verifiquei quais foram os mais pedidos e comecei a trabalhar nisso. Resultado: Levei <b>muito</b> tempo para modificar o programa e fazer com que, por exemplo, o item Expert Belt não aumentasse o dano quando o golpe usado não fosse super effective no oponente.</p>

<p>Lendo o <a href="http://catb.org/~esr/writings/taoup/html/" target="_blank">The Art of Unix Programming</a>, me deparei com a <i>Rule of Representation</i>:</p>

<blockquote>Data is more tractable than program logic. It follows that where you see a choice between complexity in data structures and complexity in code, choose the former. More: in evolving a design, you should actively seek ways to shift complexity from code to data.</blockquote>

<p>Resolvi aplicar o que diz a <i>ancient lore</i> e recomeçar a damageCalc do zero, novamente. Desta vez, com foco na criação de uma 'engine' que realize diversos tipos de cálculos, mas que os detalhes de como items e abilities afetam esses cálculos sejam armazenados, por exemplo, em um arquivo JSON. Teoricamente, isso deve facilitar minha vida futuramente.</p>

<h3>O que há</h3>

<p>Basicamente tenho 3 módulos: io, calc e engine. O primeiro recebe dados da interface e imprime o output dos cálculos; o segundo tem implementações de algoritmos para a fórmula de dano, probabilidades de 1HKO/2HKO e contabiliza entry hazards como Stealth Rock; o terceira interpreta as informações da interface e realiza modificações dependendo das escolhas de itens e abilities feitas pelo usuário.</p>

<p>Os efeitos desses itens e abilities são guardados em uma tabela que relaciona o nome do item/ability ao modifier que ele influencia (vide referência) e a uma função que executa a mudança, possivelmente com um teste booleano a respeito de alguns parâmetros.</p>

<p>Ainda falta um bocado para poder terminar e lançar esta nova versão, mas podem ver o código no github:</p>

<a href="http://github.com/agarie/damageCalc" target="_blank">http://github.com/agarie/damageCalc</a>

<h3>Referência</h3>

<a href="http://www.smogon.com/dp/articles/damage_formula" target="_blank">The Complete Damage Formula for Diamong & Pearl, by X-Act and Peterko</a>